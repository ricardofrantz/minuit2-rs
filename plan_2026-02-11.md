# Cross-Implementation Verification Plan: minuit2-rs vs Reference Minuit2

Date: 2026-02-11

## Claim-Grade Proof Plan (legacy C/C++ -> Rust)

This section defines how to make a **defensible claim** that the Rust port covers the legacy implementation and preserves mathematical behavior.

### 1) Define exactly what is being claimed

Claim boundaries must be explicit:
- Reference implementation: `root-project/root`, subtree `math/minuit2`, tag `v6-36-08`.
- Scope: Minuit2 functionality only (not full ROOT framework behavior).
- Claim type:
  - `API/feature coverage claim` (what is implemented),
  - `behavioral equivalence claim` (what outputs match),
  - `numerical accuracy claim` (math quality/stability),
  - `performance claim` (speed/cost under fixed conditions).

No “100% equivalent” statement without all four claims passing their gates.

### 2) Build a traceability matrix (legacy -> Rust)

Create one machine-readable matrix (CSV/JSON):
- Legacy symbol/test/capability identifier.
- Rust counterpart (module/function/test).
- Status: `ported`, `intentionally different`, `not implemented`.
- Evidence artifact path (test name, diff workload, benchmark).

Gate:
- 100% of in-scope legacy functions/capabilities must be mapped.
- Any unmapped item blocks a full-coverage claim.

### 3) Port and classify legacy tests

From legacy test suite, classify into:
- `P0`: correctness-critical (must pass for claim).
- `P1`: major behavior compatibility.
- `P2`: edge/auxiliary behavior.

For each test:
- direct port if API permits,
- adapter test if API differs,
- documented waiver only if out of scope.

Gate:
- P0 replication rate = 100%.
- P1 replication rate >= 95% (remaining items must have written waivers).

### 4) Differential oracle testing (C++ runner vs Rust runner)

Use dual-run harness on identical inputs:
- same objective, same start values, same bounds/fixed params, same stopping controls.
- compare: validity, params, fval, edm, covariance, Minos intervals, scan/contour outputs.

Gate:
- P0/P1 workloads: 0 correctness failures.
- Any tolerance must be predeclared per workload and justified.
- Warnings (e.g., NFCN drift) allowed only if explicitly non-correctness and documented.

### 5) Mathematical accuracy suite (independent of legacy)

Add oracle problems with known truth:
- convex quadratics with analytic minimum/Hessian/covariance,
- Rosenbrock and ill-conditioned variants,
- bounded-transform Jacobian checks,
- Minos asymmetry sanity cases.

Check invariants:
- covariance symmetric + positive semidefinite (within tolerance),
- Hessian/covariance consistency,
- finite outputs under NaN/Inf perturbations.

Gate:
- all analytic checks within strict tolerances,
- no invariant violations on stress suite.

### 6) Coverage and mutation requirements

Rust code coverage alone is insufficient, but still required:
- line/function/region coverage thresholds for core modules.
- stricter thresholds for critical math paths (Migrad/Simplex/Hesse/Minos/transforms).

Add mutation testing on critical modules to detect weak assertions.

Suggested gates:
- core line coverage >= 85% (raise over time),
- critical-path branch coverage >= 90%,
- mutation score critical-path >= 80%.

### 7) Performance claim protocol

Benchmark protocol must be reproducible:
- pinned machine/toolchain,
- fixed benchmark dataset,
- repeated Criterion runs with confidence intervals,
- compare both wall-time and NFCN-normalized cost.

Gate:
- performance claims only on statistically significant deltas.
- no blanket “faster” claim across all workloads unless all representative families support it.

### 8) CI release gates (must pass before compatibility badge)

Required CI jobs:
1. legacy traceability matrix completeness check,
2. full differential suite against pinned reference runner,
3. math oracle suite,
4. coverage + mutation thresholds,
5. benchmark regression check (non-blocking or blocking per policy).

### 9) Evidence bundle for users (trust package)

Publish with each release:
- compatibility manifest (`reference tag/commit`, rust commit, environment),
- traceability matrix snapshot,
- differential summary + raw outputs,
- known differences ledger,
- coverage and benchmark reports.

### 10) Standardized claim language

Use constrained wording in README/releases, for example:

“`minuit2-rs` is verified against ROOT Minuit2 `v6-36-08` (`math/minuit2`) on the published workload and test matrix.  
All P0/P1 correctness gates pass; documented differences are listed in `reports/verification/known_differences.md`.”

Avoid:
- “fully identical to ROOT” unless every mapped item is proven and no waivers remain.

## Execution Update (2026-02-11)

Completed in this repo:
- ROOT baseline pinned in parity tooling to `root-project/root` + `math/minuit2` + `v6-36-08` (resolved commit `a8ca1b23e38d7dbe0ff24027894ca0f2ad65f1bd`).
- Function parity artifacts regenerated from ROOT baseline:
  - `reports/parity/functions.csv`
  - `reports/parity/gaps.md`
  - `reports/parity/missing.csv`
  - `reports/parity/needs_review.csv`
- ROOT regression ports added and passing:
  - `tests/root_reference_minuit2.rs` (Hessian external indexing tests)
  - `tests/root_reference_covariance.rs` (covariance transform tests for unbounded/upper/lower/double bounds)
- Coverage and benchmark artifacts regenerated:
  - `reports/coverage/core_coverage.md`
  - `reports/coverage/all_features_coverage.md`
  - `reports/benchmarks/benchmark_baseline.md`
- Traceability artifacts and CI non-regression gate added:
  - `scripts/generate_traceability_matrix.py`
  - `scripts/check_traceability_gate.py`
  - `reports/verification/traceability_matrix.csv`
  - `reports/verification/traceability_summary.md`
  - `verification/traceability/traceability_baseline.csv`
  - `.github/workflows/ci.yml` (`traceability` job)
- Claim scorecard + manifest generation:
  - `scripts/generate_verification_scorecard.py`
  - `reports/verification/manifest.json`
  - `reports/verification/scorecard.md`

Still pending for full cross-implementation verification:
- Expand workload breadth from current 6 cases to full P0/P1 matrix (Minimizer families + MnTutorial/MnSim subsets).
- Investigate and (if desired) reduce current NFCN divergence warnings in quadratic workloads.
- Add known-differences ledger and CI automation for differential checks.

Implemented differential harness (new):
- `scripts/build_root_reference_runner.sh`
- `tools/ref_runner_cpp/main.cpp`
- `src/bin/ref_compare_runner.rs`
- `verification/workloads/root_minuit2_v6_36_08.json`
- `scripts/compare_ref_vs_rust.py`
- `reports/verification/diff_summary.md` / `reports/verification/diff_results.csv`

Latest run status:
- pass: 4
- warn: 2
- fail: 0
- traceability: implemented=303, waived=112, unresolved=0

## Why this plan exists

Current tests and coverage are not enough to make a strong public claim that the Rust port is fully equivalent to the original C++ Minuit2.
To make this defensible for new users, we need:
- reproducible correctness comparisons against the reference implementation,
- reproducible performance comparisons with fair methodology,
- machine-readable artifacts and clear pass/fail gates.

## Legitimacy Plan (New-User Proof Standard)

Question this section answers:
- "If I just discovered this Rust port, what evidence shows it truly matches ROOT Minuit2 math and behavior?"

### A) Claim Taxonomy (what we can and cannot claim)

Allowed claims (only if matching gates pass):
- **Coverage claim**: every in-scope ROOT Minuit2 symbol/capability is mapped to Rust implementation or explicit waiver.
- **Behavior claim**: for covered workloads, Rust and ROOT produce equivalent optimization outcomes within declared tolerances.
- **Math claim**: on analytic-oracle problems, Rust produces correct minima/gradients/Hessian-derived uncertainties within strict tolerance.
- **Performance claim**: benchmark statement tied to named workload + machine/toolchain + statistical confidence.

Disallowed unless fully proven:
- "Bit-identical to ROOT in all contexts."
- "Faster than ROOT everywhere."

### B) Required Evidence Layers (must all exist for release-level confidence)

Layer 1: **Traceability completeness**
- Artifact: `reports/verification/traceability_matrix.csv`
- Gate: unresolved `== 0` in strict mode.
- Current state (2026-02-11): pass (`implemented=303`, `waived=112`, `unresolved=0`).

Layer 2: **ROOT test replication**
- Artifact: `reports/verification/root_test_replication_matrix.md`
- Gate: all P0 tests replicated and passing; P1/P2 either replicated or waived with rationale.
- Current state: P0 subset currently replicated passes; broader P1/P2 expansion still pending.

Layer 3: **Legacy dynamic coverage (executed C++ surface)**
- Artifacts:
  - C++ Minuit2 coverage report generated from ROOT `math/minuit2` test/workload runs,
  - executed legacy file/function list,
  - mapping of executed legacy functions to Rust tests/workloads.
- Gate:
  - for each executed legacy function in scope, there is at least one Rust-side evidence item (test/diff workload),
  - no executed legacy P0/P1 function remains unmapped.
- Current state: instrumentation/reporting is implemented via `scripts/generate_reference_coverage.py` (latest: 524/1716 functions executed, 30.54%); mapping gate is not yet automated.

Layer 4: **Differential execution (ROOT runner vs Rust runner)**
- Artifacts: `reports/verification/diff_results.csv`, `reports/verification/diff_summary.md`
- Gate for correctness: `fail == 0`.
- Strong gate for "100% verifiable": `fail == 0` and `warn == 0`.
- Current state: pass=4, warn=2, fail=0 (correctness passes; strict 100% gate blocked by warnings).

Layer 5: **Independent math oracles**
- Artifacts: deterministic analytic fixtures and invariant checks in Rust tests.
- Gate: all analytic tolerances pass; no covariance/Hessian invariant violations.
- Current state: partially present; needs formal "oracle suite manifest" and CI gate.

Layer 6: **Coverage + mutation resistance**
- Artifacts: `reports/coverage/*.md` plus mutation report.
- Gate proposal:
  - line coverage >= 85% for core no-default build,
  - line coverage >= 80% for all-features,
  - mutation score >= 80% in critical math modules.
- Current state: below proposed coverage thresholds; mutation gate not yet implemented.

Layer 7: **Performance protocol**
- Artifact: `reports/benchmarks/benchmark_baseline.md`
- Gate: only workload-specific claims with confidence bounds; no global speed claims.
- Current state: benchmark harness present; currently indicates scan-parallel path is slower in measured setup.

### C) Execution Phases (ordered)

Phase 1 (now): lock reference and regenerate baseline
- Pin reference to ROOT `math/minuit2` tag `v6-36-08` commit `a8ca1b23e38d7dbe0ff24027894ca0f2ad65f1bd`.
- Run: `scripts/run_full_verification.sh v6-36-08`.
- Deliverable: refreshed `scorecard.md` + `manifest.json`.

Phase 2: complete ROOT regression replication matrix
- Expand from current P0 subset to full P0 + targeted P1 from:
  - `testMinimizer.cxx`
  - `MnTutorial/Quad*.cxx`
  - deterministic subset of `MnSim`.
- Deliverable: status table with each ROOT source test mapped to Rust test path + result.

Phase 3: add legacy dynamic coverage gate (C++ executed-surface proof)
- Build ROOT Minuit2 with coverage instrumentation.
- Run selected ROOT tests + differential workloads through reference runner.
- Export executed function/file coverage for `math/minuit2`.
- Join executed legacy function list with Rust traceability and evidence map.
- Deliverable: "executed legacy surface mapped to Rust evidence" report; zero unmapped P0/P1 functions.

Phase 4: expand differential workload breadth
- Increase workload count from 6 to representative matrix:
  - Migrad, Simplex, Minimize, Hesse, Minos, Scan, Contours
  - bounded/unbounded/fixed parameters
  - smooth vs ill-conditioned objectives.
- Keep deterministic seeds and checked-in workload specs.
- Deliverable: diff matrix with 0 fails and documented warning policy.

Phase 5: resolve warning-only divergences (NFCN)
- Investigate two current warning workloads:
  - `quadratic3_fixx_migrad`
  - `quadratic3_fixx_hesse`
- Decide policy:
  - either algorithmically reduce divergence,
  - or keep as non-correctness difference with explicit rationale and threshold.
- Deliverable: warning-free strict gate or explicit policy exception.

Phase 6: add mutation testing for critical math paths
- Scope: migrad builder/update, hesse gradient, minos crossing, line search, transforms.
- Deliverable: mutation score report + CI threshold.

Phase 7: publish trust bundle per release
- Required files:
  - `reports/verification/manifest.json`
  - `reports/verification/scorecard.md`
  - `reports/verification/diff_summary.md`
  - `reports/verification/traceability_summary.md`
  - `reports/verification/known_differences.md`
- Release note language must include exact reference tag/commit and gate outcomes.

### D) Honest Current Position (2026-02-11)

What is already defensible:
- Port is verifiably aligned with ROOT `math/minuit2` `v6-36-08` on the covered differential workloads (`fail=0`).
- Strict traceability mapping has no unresolved symbols.
- Current replicated ROOT P0 regression subset passes.

What is not yet defensible:
- A blanket "100% verifiable coverage" statement for all practical workloads.
- A blanket "faster than reference" statement.

What would make "100% verifiable coverage" defensible here:
- Differential warnings reduced to zero or formally reclassified with agreed policy,
- broader workload matrix (especially P1/P2 ROOT tests) completed,
- explicit math-oracle and mutation gates passing in CI.

Canonical port target (explicit):
- Repository: `https://github.com/root-project/root`
- Subtree: `math/minuit2`
- Target release baseline: `v6-36-08`
- Scope boundary: Minuit2 functionality only (exclude non-Minuit2 ROOT framework layers from 1:1 claims)

## Versioning Strategy (Rust vs C++ Reference)

Observation from repository metadata:
- Canonical upstream for this port should be ROOT monorepo path:
  - `root-project/root/tree/master/math/minuit2`
- As of 2026-02-11:
  - latest ROOT release: `v6-36-08` (published 2026-02-05)
  - newer development tags exist (e.g., `v6-39-01`), but release claims should be tied to a stable release tag.

Decision:
- Do **not** force Rust crate version to numerically match C++ tag numbers.
- Keep Rust crate SemVer for Rust API stability.
- Publish explicit compatibility mapping to reference tag/commit.

Why:
- Numeric version matching alone can imply 1:1 parity that we have not yet fully proven.
- Rust API evolution and upstream C++ lineage are related but not identical dimensions.

Required compatibility signaling:
1. Add a compatibility table to docs:
   - Rust crate version
   - Reference repo tag
   - Reference commit hash
   - Differential pass rate
   - Known differences count
2. Add runtime constants (or metadata) for traceability:
   - `REFERENCE_MINUIT2_TAG`
   - `REFERENCE_MINUIT2_COMMIT`
3. Include compatibility statement in every release note.

Optional policy after full verification:
- If/when we achieve verified 1:1 behavior for a specific reference tag, include release subtitle:
  - "`minuit2-rs vX.Y.Z` compatible with ROOT Minuit2 `v6-36-08` (verified suite hash ...)".

## Claim Gate (what must be true before saying "legit")

We only claim strong parity when all are true:
1. Reference and Rust are compared on the same pinned workloads and same input data.
2. Differences are within pre-declared tolerances (or explicitly explained in a known-differences ledger).
3. Results are reproducible by third parties with one command.
4. Performance conclusions are based on stable repeated runs and include uncertainty, not single-run snapshots.

## Scope

Algorithms/features to validate:
- MnMigrad
- MnSimplex
- MnMinimize
- MnHesse
- MnMinos
- MnScan
- MnContours

Metrics to compare:
- convergence validity flags
- parameter values
- function value (fval)
- EDM
- NFCN
- covariance matrix
- Minos lower/upper errors
- scan profiles
- contour geometry

## Phase 0: Freeze Baselines

1. Pin upstream C++ reference commit from `root-project/root` and record both:
   - root tag (e.g., `v6-36-08`)
   - root commit hash
   - minuit2 subtree path (`math/minuit2`)
2. Pin Rust commit under test.
3. Capture toolchain and environment metadata:
   - compiler versions (`clang/gcc`, `rustc`, `cargo`)
   - build flags
   - CPU model/core count
   - OS/kernel
4. Save as `reports/verification/manifest.json`.

Acceptance:
- Every comparison report references exact commit hashes and environment fingerprint.

## Phase 1: Build Reference Runner (C++)

1. Vendor or clone ROOT under `third_party/root_ref/` at pinned tag/commit.
2. Build only what is needed for Minuit2 runner (avoid full ROOT feature build where possible).
3. Add a thin C++ runner executable:
   - input: workload JSON
   - output: normalized result JSON
4. Normalize outputs into fixed schema (same names/units as Rust runner).

Proposed output file:
- `tools/ref_runner` producing `reports/verification/raw/ref/*.json` (linked to ROOT tag/commit metadata).

Acceptance:
- Reference runner builds and executes all baseline workloads.

## Phase 2: Build Rust Runner (mirror schema)

1. Add Rust runner executable with identical input/output schema to C++ runner.
2. Ensure deterministic behavior where possible (fixed seeds for stochastic inputs).
3. Emit `reports/verification/raw/rust/*.json`.

Acceptance:
- For any workload spec, both runners produce valid schema outputs.

## Phase 3: Canonical Workload Suite

Create `verification/workloads/*.json` with:
- smooth convex (2D and ND quadratics)
- Rosenbrock valley
- bounded-only, fixed-parameter, mixed constraints
- synthetic Gaussian fit
- ill-conditioned covariance scenarios
- Minos-sensitive asymmetric objective
- scan/contours-focused cases
- stress/high-dimensional cases

Rules:
- deterministic datasets checked into repo
- no hidden random generation unless seeded and logged

Acceptance:
- Suite covers each algorithm and key edge cases.

ROOT test replication tracking:
- Matrix file: `reports/verification/root_test_replication_matrix.md`
- Goal: replicate/adapt ROOT `math/minuit2/test` coverage into Rust-native tests with explicit mapping and status.

## Phase 4: Differential Comparator

Implement `scripts/compare_ref_vs_rust.py`:
- runs both executables for each workload/algorithm
- compares with metric-specific tolerances:
  - parameters/fval/edm: abs + relative tolerances
  - covariance: relative Frobenius + SPD checks
  - Minos intervals: signed interval tolerance
  - scan curves: pointwise + area error
  - contours: point-set distance (e.g., Hausdorff proxy)
- labels each case: `pass`, `warn`, `fail`
- writes:
  - `reports/verification/diff_summary.md`
  - `reports/verification/diff_results.csv`
  - `reports/verification/failures/*.json`

Acceptance:
- Comparator produces deterministic pass/fail output for full suite.

## Phase 5: Known Differences Ledger

For each non-pass case:
- root-cause category (`precision`, `algorithmic refactor`, `bug`, `unsupported`)
- severity
- expected/unexpected
- disposition (`fix`, `document`, `defer`)

Output:
- `reports/verification/known_differences.md`

Acceptance:
- No unexplained failures remain.

## Phase 6: Performance Evaluation (Fair + Useful)

Methodology:
1. Compare end-to-end runtime per workload and per algorithm.
2. Also compare normalized efficiency:
   - time per function call
   - NFCN to convergence
3. Use repeated runs with medians and spread (p50/p95, confidence intervals).
4. Isolate benchmark environment:
   - fixed CPU power profile
   - minimal background load
   - same build optimization level

Outputs:
- `reports/benchmarks/ref_vs_rust.md`
- `reports/benchmarks/ref_vs_rust.csv`

Acceptance:
- Performance statements always include uncertainty and environment metadata.

## Phase 7: CI + Reproducibility

1. Add workflow jobs:
   - correctness differential suite
   - performance smoke (full perf on nightly/self-hosted runner)
2. Store artifacts for every run.
3. One-command local verification entrypoint:
   - `make verify-ref-compare`

Acceptance:
- Any contributor can reproduce headline claims locally.

## Public-Facing Trust Statement Template

Only after passing gates:
- "Compared against upstream commit <hash> on <date> across <N> workloads."
- "Correctness: <pass_rate>% pass, <known_diff_count> documented differences."
- "Performance: Rust median speed ratio vs C++ by workload family, with CI range."

Without this, we should state:
- "Port is functional and tested, but full cross-implementation verification is still in progress."

## Execution Order (recommended)

1. Phase 0 + 1 (reference runner + pinning)
2. Phase 2 + 3 (Rust runner + workload suite)
3. Phase 4 (comparator + first diff report)
4. Fix/ledger loop (Phase 5)
5. Phase 6 performance report
6. Phase 7 automation

## Concrete next sprint (first 5 tasks)

1. Add `third_party/root_ref/` pin and build script.
2. Implement minimal C++ runner for Migrad/Hesse/Minos JSON output.
3. Implement matching Rust runner.
4. Create initial 12-workload canonical suite.
5. Generate first `diff_summary.md` with real pass/fail counts.

## Continuation Plan (Post-Commit Baseline)

Date: 2026-02-11
Objective: move from "strong partial evidence" to "defensible full verification claim" for ROOT `math/minuit2` `v6-36-08`.

### Step 1: Expand executed legacy surface
1. Add 12-20 new deterministic workloads (beyond current 6), covering:
   - Migrad, Simplex, Minimize, Hesse, Minos, Scan, Contours
   - bounded + unbounded + fixed parameters
   - ill-conditioned and asymmetric objectives
2. Re-run `python3 scripts/generate_reference_coverage.py --root-tag v6-36-08`.
3. Target: executed C++ function coverage > 60% for `math/minuit2`.

### Step 2: Add executed-surface mapping gate
1. Create script to join:
   - `reports/verification/reference_coverage/executed_functions.csv`
   - `reports/verification/traceability_matrix.csv`
   - Rust evidence references (test/workload id).
2. Output:
   - `reports/verification/executed_surface_mapping.md`
   - `reports/verification/executed_surface_gaps.csv`
3. Gate: zero unmapped executed P0/P1 legacy functions.

### Step 3: Replicate more ROOT tests
1. Port prioritized cases from:
   - `testMinimizer.cxx`
   - `MnTutorial/Quad*.cxx`
   - deterministic subset of `MnSim`.
2. Update `reports/verification/root_test_replication_matrix.md` and `reports/verification/root_test_port_status.md`.
3. Gate: P0 complete and P1 >= 95% replicated or explicitly waived.

### Step 4: Close strict differential warnings
1. Investigate NFCN warning workloads:
   - `quadratic3_fixx_migrad`
   - `quadratic3_fixx_hesse`
2. Either align algorithmic behavior or document/approve policy exception with rationale.
3. Gate: `fail == 0` and `warn == 0` for strict "100% verifiable coverage" claim.

### Step 5: Raise Rust-side assurance
1. Increase coverage thresholds toward:
   - core no-default line coverage >= 85%
   - all-features line coverage >= 80%
2. Add mutation testing for critical modules (migrad/hesse/minos/transforms/line search).
3. Integrate all gates into CI and publish release evidence bundle.
